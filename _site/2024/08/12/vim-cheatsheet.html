<!DOCTYPE html><html lang="en" ><head><title>Ovidiu Pârvu | Vim cheatsheet</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.post ul,.project ul,.post ol{list-style-position:inside}.post ul li,.project ul li,.post ol li{padding-left:1rem}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}</style><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ovidiu Pârvu | Technical blog" /><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Vim cheatsheet" /><meta name="author" content="Ovidiu Pârvu" /><meta property="og:locale" content="en_US" /><meta name="description" content="A vim cheatsheet created while reading Practical Vim, Second Edition, is given below." /><meta property="og:description" content="A vim cheatsheet created while reading Practical Vim, Second Edition, is given below." /><link rel="canonical" href="http://localhost:4000/2024/08/12/vim-cheatsheet" /><meta property="og:url" content="http://localhost:4000/2024/08/12/vim-cheatsheet" /><meta property="og:site_name" content="Ovidiu Pârvu Technical blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-12T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Vim cheatsheet" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Ovidiu Pârvu"},"dateModified":"2024-08-12T00:00:00+01:00","datePublished":"2024-08-12T00:00:00+01:00","description":"A vim cheatsheet created while reading Practical Vim, Second Edition, is given below.","headline":"Vim cheatsheet","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/08/12/vim-cheatsheet"},"url":"http://localhost:4000/2024/08/12/vim-cheatsheet"}</script></head><body><main role="main"><header role="banner"><nav role="navigation"><ul><li><a href="/" >Blog</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><section class="post"><h2>Vim cheatsheet</h2><p>A vim cheatsheet created while reading <a href="https://pragprog.com/titles/dnvim2/practical-vim-second-edition">Practical Vim, Second Edition</a>, is given below.</p><h1 id="undoredo">Undo/redo</h1><p><code class="language-plaintext highlighter-rouge">.</code> - Repeats last change (including what happened from the moment one enters the Insert mode until one returns to the Normal mode)<br /> <code class="language-plaintext highlighter-rouge">;</code> - Repeat last search that the <code class="language-plaintext highlighter-rouge">f</code> command performed<br /> <code class="language-plaintext highlighter-rouge">,</code> - Repeat last search that the <code class="language-plaintext highlighter-rouge">f</code> command performed in the reverse direction<br /> <code class="language-plaintext highlighter-rouge">n</code> - Repeat last search<br /> <code class="language-plaintext highlighter-rouge">N</code> - Repeat last search in reverse<br /> <code class="language-plaintext highlighter-rouge">&amp;</code> - Repeat last substitution<br /> <code class="language-plaintext highlighter-rouge">@x</code> - Repeat sequence of changes recorded in register x (using qx{changes}q)<br /> <code class="language-plaintext highlighter-rouge">@:</code> - Repeat the last Ex command</p><p><code class="language-plaintext highlighter-rouge">u</code> - Undo last change<br /> <code class="language-plaintext highlighter-rouge">&lt;C-r&gt;</code> - Redo last change</p><h1 id="jumping">Jumping</h1><p><code class="language-plaintext highlighter-rouge">0</code> - Jump to beginning of line<br /> <code class="language-plaintext highlighter-rouge">$</code> - Jump to EOL<br /> <code class="language-plaintext highlighter-rouge">^</code> - Jump to beginning of non-whitespace line contents<br /> <code class="language-plaintext highlighter-rouge">f/F{char}</code> - Scan line for next/previous character {char} and jump to it<br /> <code class="language-plaintext highlighter-rouge">t/T{char}</code> - Scan line for next/previous character {char} and jump immediately before it<br /> <code class="language-plaintext highlighter-rouge">/pattern&lt;CR&gt;</code> - Jump to next<pattern> match `?pattern<CR>` - Jump to previous<pattern> match `<C-r><C-w>` - Autocomplete the search field using the remainder of the current preview match</C-w></C-r></pattern></CR></pattern></p><p><code class="language-plaintext highlighter-rouge">&lt;C-]&gt;</code> - Jump to definition (if ctags is configured)</p><p><code class="language-plaintext highlighter-rouge">zz</code> - Redraw the screen with the current line in the vertical middle of the window</p><h1 id="modes">Modes</h1><p><code class="language-plaintext highlighter-rouge">i</code> - Enter Insert mode<br /> <code class="language-plaintext highlighter-rouge">r</code> - Enter Replace mode for a single character<br /> <code class="language-plaintext highlighter-rouge">R</code> - Enter Replace mode<br /> <code class="language-plaintext highlighter-rouge">&lt;C-g&gt;</code> - Toggle between Visual and Select mode<br /> <code class="language-plaintext highlighter-rouge">v</code> - Enter character-wise Visual mode<br /> <code class="language-plaintext highlighter-rouge">V</code> - Enter line-wise Visual mode<br /> <code class="language-plaintext highlighter-rouge">&lt;C-v&gt;</code> - Enter block-wise Visual mode<br /> <code class="language-plaintext highlighter-rouge">gv</code> - Reselect the last visual selection<br /> <code class="language-plaintext highlighter-rouge">:</code> - Enter command line mode</p><p><code class="language-plaintext highlighter-rouge">q/</code> - Open command-line window</p><h1 id="buffers-windows-and-tabs">Buffers, windows and tabs</h1><p><code class="language-plaintext highlighter-rouge">:ls</code> - List all buffers that have been loaded into memory<br /> <code class="language-plaintext highlighter-rouge">:args</code> - Populate or list contents of the argument list<br /> <code class="language-plaintext highlighter-rouge">:w[rite]</code> - Write the contents of the buffer to disk<br /> <code class="language-plaintext highlighter-rouge">:w !sudo tee % &gt;/dev/null</code> - Write the contents of the buffer to disk using sudo permissions<br /> <code class="language-plaintext highlighter-rouge">:e[dit]!</code> - Re-read from disk the file corresponding to the current buffer<br /> <code class="language-plaintext highlighter-rouge">:wa[ll]</code> - Write all modified buffers to disk<br /> <code class="language-plaintext highlighter-rouge">:qa[ll]</code> - Close all windows, discarding changes without warning</p><p><code class="language-plaintext highlighter-rouge">&lt;C-w&gt;v</code> - Split window vertically<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;s</code> - Split window horizontally<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;w</code> - Cycle between open windows<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;h</code> - Focus the window to the left<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;j</code> - Focus the window below<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;k</code> - Focus the window above<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;l</code> - Focus the window to the right<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;c</code> - Close the active window<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;o</code> - Only leave the active window open<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;=</code> - Equalize width and height of all windows</p><p><code class="language-plaintext highlighter-rouge">:tabe[dit] {filename}</code> - Open {filename} in a new tab<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;T</code> - Move the current window into its own tab<br /> <code class="language-plaintext highlighter-rouge">:tabc[lose]</code> - Close the current tab page and all of its windows<br /> <code class="language-plaintext highlighter-rouge">:tabo[nly]</code> - Keep the active tab page, close all others<br /> <code class="language-plaintext highlighter-rouge">:tabn[ext] {N}</code> - Switch to tab page number {N} ({N}gt in normal mode)<br /> <code class="language-plaintext highlighter-rouge">:tabn[ext] {N}</code> - Switch to next tab page (gt in normal mode)<br /> <code class="language-plaintext highlighter-rouge">:tabp[revious]</code> - Switch to the previous tab page (gT in normal mode)</p><p><code class="language-plaintext highlighter-rouge">:edit %&lt;Tab&gt;</code> - % symbol is a shorthand for the filepath of the active buffer<br /> <code class="language-plaintext highlighter-rouge">:edit %:h&lt;Tab&gt;</code> - The :h modifier removes the filename while preserving the rest of the path<br /> <code class="language-plaintext highlighter-rouge">:find {filename}</code> - Open a file by its filename (without fully qualifying it with the absolute path)<br /> <code class="language-plaintext highlighter-rouge">:edit .</code> - Open file explorere for current working directory<br /> <code class="language-plaintext highlighter-rouge">:Explore</code> - Open file explorer for the directory of the active buffer</p><p><code class="language-plaintext highlighter-rouge">&lt;C-g&gt;</code> - Echo the name and status of the current file</p><h1 id="marks">Marks</h1><p><code class="language-plaintext highlighter-rouge">m{a-zA-Z}</code> - Create a mark at the current cursor location with the designated letter<br /> <code class="language-plaintext highlighter-rouge">'{mark}</code> - Jump to the line where the mark was set<br /> <code class="language-plaintext highlighter-rouge">`{mark}</code> - Jump to the cursor location of where the mark was set</p><h1 id="commands">Commands</h1><p><code class="language-plaintext highlighter-rouge">:vim[grep][!] /{pattern}/[g][j] {file} ...</code> - Project-wide search<br /> <code class="language-plaintext highlighter-rouge">:copen</code> - Open quickfix window<br /> <code class="language-plaintext highlighter-rouge">:cfdo {cmd}</code> - Run {cmd} against all files in the quickfix window</p><p><code class="language-plaintext highlighter-rouge">:[range] global[!] /{pattern}/ {cmd}</code> - Run Ex command {cmd} against all lines in [range] matching {pattern}<br /> <code class="language-plaintext highlighter-rouge">:[range] vglobal/v[!] /{pattern}/ {cmd}</code> - Run Ex command {cmd} against all lines in [range] that do not match {pattern}</p><h1 id="registers">Registers</h1><p><code class="language-plaintext highlighter-rouge">"{register}</code> - Reference a particular register<br /> <code class="language-plaintext highlighter-rouge">"_</code> - Black hole register<br /> <code class="language-plaintext highlighter-rouge">""</code> - Unnamed register<br /> <code class="language-plaintext highlighter-rouge">"0</code> - yank register<br /> <code class="language-plaintext highlighter-rouge">:reg "0</code> - Inspect the contents of the yank register<br /> <code class="language-plaintext highlighter-rouge">"+</code> - System clipboard<br /> <code class="language-plaintext highlighter-rouge">"*</code> - Selection register<br /> <code class="language-plaintext highlighter-rouge">"=</code> - Expression register<br /> <code class="language-plaintext highlighter-rouge">"%</code> - Name of the current file<br /> <code class="language-plaintext highlighter-rouge">"#</code> - Name of the alternate file<br /> <code class="language-plaintext highlighter-rouge">".</code> - Last inserted text<br /> <code class="language-plaintext highlighter-rouge">":</code> - Last Ex command<br /> <code class="language-plaintext highlighter-rouge">"/</code> - Last search pattern<br /> <code class="language-plaintext highlighter-rouge">&lt;C-r&gt;{register}</code> - Paste contents of {register} register</p><h1 id="macros">Macros</h1><p><code class="language-plaintext highlighter-rouge">q{register}</code> - Start recording into {register} register<br /> <code class="language-plaintext highlighter-rouge">q{uppercase register}</code> - Append to the {register} register<br /> <code class="language-plaintext highlighter-rouge">q</code> - Stop recording<br /> <code class="language-plaintext highlighter-rouge">@{register}</code> - Execute the contents of the {register} register<br /> <code class="language-plaintext highlighter-rouge">@@</code> - Repeat macro invoked most recently<br /> <code class="language-plaintext highlighter-rouge">:put {register}</code> - Paste the contents of the {register} register into the buffer</p><h1 id="jump-list">Jump list</h1><p><code class="language-plaintext highlighter-rouge">:jumps</code> - List contents of jump list<br /> <code class="language-plaintext highlighter-rouge">&lt;C-o&gt;</code> - Jump back<br /> <code class="language-plaintext highlighter-rouge">&lt;C-i&gt;</code> - Jump forward<br /> <code class="language-plaintext highlighter-rouge">[count]G</code> - Jump to line number<br /> <code class="language-plaintext highlighter-rouge">/pattern&lt;CR&gt;/?pattern&lt;CR&gt;/n/N</code> - Jump to next/previous occurrence of pattern<br /> <code class="language-plaintext highlighter-rouge">%</code> - Jump between opening and closing sets of parentheses<br /> <code class="language-plaintext highlighter-rouge">(/)</code> - Jump to start of previous/next sentence<br /> <code class="language-plaintext highlighter-rouge">{/}</code> - Jump to start of previous/next paragraph<br /> <code class="language-plaintext highlighter-rouge">H/M/L</code> - Jump to top/middle/bottom of screen<br /> <code class="language-plaintext highlighter-rouge">gf</code> - Jump to file name under the cursor<br /> <code class="language-plaintext highlighter-rouge">&lt;C-]&gt;</code> - Jump to definition of keyword under the cursor</p><h1 id="change-list">Change list</h1><p><code class="language-plaintext highlighter-rouge">:changes</code> - Open the change list<br /> <code class="language-plaintext highlighter-rouge">g,</code> - Jump to next change in the change list<br /> <code class="language-plaintext highlighter-rouge">g;</code> - Jump to the previous change in the change list<br /> <code class="language-plaintext highlighter-rouge">gi</code> - Resume from last position from which we exited Insert mode</p><h1 id="automatic-marks">Automatic marks</h1><p><code class="language-plaintext highlighter-rouge">``</code> - Position before the last jump within the current file<br /> <code class="language-plaintext highlighter-rouge">`.</code> - Position of last change<br /> <code class="language-plaintext highlighter-rouge">`^</code> - Location of last insertion<br /> <code class="language-plaintext highlighter-rouge">`[</code> - Start of last change or yank<br /> <code class="language-plaintext highlighter-rouge">`]</code> - End of last change or yank<br /> <code class="language-plaintext highlighter-rouge">`&lt;</code> - Start of last visual selection<br /> <code class="language-plaintext highlighter-rouge">`&gt;</code> - End of last visual selection</p><h1 id="text-objects">Text objects</h1><p>Vim’s text objects consist of two characters, the first of which is always either i (i.e. inside) or a (i.e. around).</p><p><code class="language-plaintext highlighter-rouge">i/a{)}]&gt;'"</code>}<code class="language-plaintext highlighter-rouge"> - inside/around {)}]&gt;'"</code>}<br /> <code class="language-plaintext highlighter-rouge">i/a{t}</code> - inside/around tags<br /> <code class="language-plaintext highlighter-rouge">i/a{w}</code> - inside/around words<br /> <code class="language-plaintext highlighter-rouge">i/a{s}</code> - inside/around sentences<br /> <code class="language-plaintext highlighter-rouge">i/a{p}</code> - inside/around paragraphs</p><h1 id="compound-commands">Compound commands</h1><p><code class="language-plaintext highlighter-rouge">C == c$</code> (change until EOL)<br /> <code class="language-plaintext highlighter-rouge">s == cl</code> (change letter)<br /> <code class="language-plaintext highlighter-rouge">S == ^C</code> (jump to beginning of non-whitespace line contents and change until EOL)<br /> <code class="language-plaintext highlighter-rouge">I == ^i</code><br /> <code class="language-plaintext highlighter-rouge">A == $a</code><br /> <code class="language-plaintext highlighter-rouge">o == A&lt;CR&gt;</code><br /> <code class="language-plaintext highlighter-rouge">O == ko</code></p><h1 id="motions">Motions</h1><p><code class="language-plaintext highlighter-rouge">j</code> - Down one real line<br /> <code class="language-plaintext highlighter-rouge">gj</code> - Down one display line<br /> <code class="language-plaintext highlighter-rouge">k</code> - Up one real line<br /> <code class="language-plaintext highlighter-rouge">gk</code> - Up one display line<br /> <code class="language-plaintext highlighter-rouge">0</code> - The first character of real line<br /> <code class="language-plaintext highlighter-rouge">g0</code> - The first character of display line<br /> <code class="language-plaintext highlighter-rouge">^</code> - The first nonblank character of real line<br /> <code class="language-plaintext highlighter-rouge">g^</code> - The first nonblank character of display line<br /> <code class="language-plaintext highlighter-rouge">$</code> - The end of real line<br /> <code class="language-plaintext highlighter-rouge">g$</code> - The end of display line<br /> <code class="language-plaintext highlighter-rouge">w</code> - Forward to start of next word<br /> <code class="language-plaintext highlighter-rouge">b</code> - Backward to start of current/previous word<br /> <code class="language-plaintext highlighter-rouge">e</code> - Forward to end of current/next word<br /> <code class="language-plaintext highlighter-rouge">ge</code> - Backward to end of previous word</p><h1 id="operators">Operators</h1><p><code class="language-plaintext highlighter-rouge">c</code> - Change<br /> <code class="language-plaintext highlighter-rouge">d</code> - Delete<br /> <code class="language-plaintext highlighter-rouge">y</code> - Yank into register<br /> <code class="language-plaintext highlighter-rouge">g~</code> - Swap case<br /> <code class="language-plaintext highlighter-rouge">gu</code> - Make lowercase<br /> <code class="language-plaintext highlighter-rouge">gU</code> - Make uppercase<br /> <code class="language-plaintext highlighter-rouge">&gt;</code> - Shift right<br /> <code class="language-plaintext highlighter-rouge">&lt;</code> - Shift left<br /> <code class="language-plaintext highlighter-rouge">=</code> - Autoindent<br /> <code class="language-plaintext highlighter-rouge">!</code> - Filter {motion} lines through an external program</p><h1 id="autocomplete">Autocomplete</h1><p><code class="language-plaintext highlighter-rouge">&lt;C-n&gt;</code> - Invoke generic keyword autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-n&gt;</code> - Invoke current buffer keyword autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-i&gt;</code> - Invoke included file keyword autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-]&gt;</code> - Invoke tags file keyword autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-k&gt;</code> - Invoke dictionary lookup autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-l&gt;</code> - Invoke whole line autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-f&gt;</code> - Invoke filename autocompletion<br /> <code class="language-plaintext highlighter-rouge">&lt;C-x&gt;&lt;C-o&gt;</code> - Invoke omni-completion</p><h1 id="autocomplete-pop-up-menu-commands">Autocomplete pop-up menu commands</h1><p><code class="language-plaintext highlighter-rouge">&lt;C-n&gt;</code> - Use the next match<br /> <code class="language-plaintext highlighter-rouge">&lt;C-p&gt;</code> - Use the previous match<br /> <code class="language-plaintext highlighter-rouge">&lt;Down&gt;</code> - Select the next match from the word list<br /> <code class="language-plaintext highlighter-rouge">&lt;Up&gt;</code> - Select the previous match from the word list<br /> <code class="language-plaintext highlighter-rouge">&lt;C-y&gt;</code> - Accept the currently selected match<br /> <code class="language-plaintext highlighter-rouge">&lt;C-e&gt;</code> - Exit and revert to the originally typed text<br /> <code class="language-plaintext highlighter-rouge">&lt;C-h&gt;</code> - Delete one character from current match<br /> <code class="language-plaintext highlighter-rouge">&lt;C-l&gt;</code> - Add one character from current match<br /> <code class="language-plaintext highlighter-rouge">{char}</code> - Stop completion and insert {char}</p><h1 id="insert-mode">Insert mode</h1><p><code class="language-plaintext highlighter-rouge">&lt;C-h&gt;</code> - Delete back one character (like backspace)<br /> <code class="language-plaintext highlighter-rouge">&lt;C-w&gt;</code> - Delete back one word<br /> <code class="language-plaintext highlighter-rouge">&lt;C-u&gt;</code> - Delete back to start of line<br /> <code class="language-plaintext highlighter-rouge">&lt;C-o&gt;</code> - Switch to Insert Normal mode<br /> <code class="language-plaintext highlighter-rouge">&lt;C-r&gt;{register}</code> - Insert contents of register {register}<br /> <code class="language-plaintext highlighter-rouge">&lt;C-r&gt;=</code> - Access the expression register<br /> <code class="language-plaintext highlighter-rouge">&lt;C-v&gt;{code}</code> - Insert character using its numeric code.<br /> <code class="language-plaintext highlighter-rouge">&lt;C-v&gt;u{code}</code> - Insert Unicode character<br /> <code class="language-plaintext highlighter-rouge">&lt;C-v&gt;{nondigit}</code> - Insert nondigit literally<br /> <code class="language-plaintext highlighter-rouge">&lt;C-k&gt;{char1}{char2}</code> - Insert character represented by {char1}{char2} digraph</p><h1 id="visual-mode">Visual mode</h1><p><code class="language-plaintext highlighter-rouge">o</code> - Go to the other end of highlighted text</p><h1 id="command-line-mode">Command line mode</h1><p><code class="language-plaintext highlighter-rouge">:[range]delete [x]</code> - Delete specified lines [into register x]<br /> <code class="language-plaintext highlighter-rouge">:[range]yank [x]</code> - Yank specified lines [into register x]<br /> <code class="language-plaintext highlighter-rouge">:[line]put [x]</code> - Put text from register x after the specified line<br /> <code class="language-plaintext highlighter-rouge">:[range]copy {address}</code> - Copy the specified lines to below the line specified by {address}. Shorthand - :t<br /> <code class="language-plaintext highlighter-rouge">:[range]move {address} </code>- Move the specified lines to below the line specified by {address}. Shorthand - :m<br /> <code class="language-plaintext highlighter-rouge">:[range]join</code> - Join the specified lines<br /> <code class="language-plaintext highlighter-rouge">:[range]normal {commands}</code> - Execute Normal mode {commands} on each specified line<br /> <code class="language-plaintext highlighter-rouge">:[range]substitute/{pattern}/{string}/[flags]</code> - Replace occurrences of {pattern} with {string} on each specified line<br /> <code class="language-plaintext highlighter-rouge">:[range]global/{pattern}/[cmd]</code> - Execute the Ex command [cmd] on all specified lines where the {pattern} matches<br /> <code class="language-plaintext highlighter-rouge">:shell</code> - Start an interactive shell session from vim<br /> <code class="language-plaintext highlighter-rouge">:read !{cmd}</code> - Put the output from {cmd} into our current buffer<br /> <code class="language-plaintext highlighter-rouge">:[range]write !{cmd}</code> - Pass the contents of the lines from the current buffer as standard input to the external command {cmd}<br /> <code class="language-plaintext highlighter-rouge">:[range]!{filter}</code> - Filter the specified [range] through external program {filter}<br /> <code class="language-plaintext highlighter-rouge">:source {file}</code> - Run all the Ex commands from {file} against the current buffer<br /> <code class="language-plaintext highlighter-rouge">&lt;C-d&gt;</code> - Show list of possible (auto-)completions<br /> <code class="language-plaintext highlighter-rouge">&lt;C-r&gt;&lt;C-w&gt;</code> - Copy word under cursor and insert it at the command-line prompt<br /> <code class="language-plaintext highlighter-rouge">&lt;C-f&gt;</code> - Switch fom command-line mode to the command-line window<br /> <code class="language-plaintext highlighter-rouge">q/</code> - Open the command-line window with history of searches<br /> <code class="language-plaintext highlighter-rouge">q:</code> - Open the command-line window with history of Ex commands</p><h1 id="patterns">Patterns</h1><p><code class="language-plaintext highlighter-rouge">\v</code> switch at the start of a search pattern enables the very magic search mode, which causes all subsequent characters to take on a special meaning.<br /> <code class="language-plaintext highlighter-rouge">\V</code> switch at the start of a search pattern enables the verbatim search mode.<br /> <code class="language-plaintext highlighter-rouge">\x</code> character class stands for [0-9A-Fa-f].<br /> <code class="language-plaintext highlighter-rouge">\zs</code>, <code class="language-plaintext highlighter-rouge">\ze</code> - for cropping a match<br /> <code class="language-plaintext highlighter-rouge">/{pattern}/e</code> - Search and place the cursor at the end of any matches rather than at the start</p><h1 id="ranges---startend">Ranges - {start},{end}</h1><p><code class="language-plaintext highlighter-rouge">{start}</code> and <code class="language-plaintext highlighter-rouge">{end}</code> are addresses.</p><h1 id="addresses---address">Addresses - {address}</h1><p>They can be specified using a line number, a mark or a pattern.</p><p>Special address symbols: <code class="language-plaintext highlighter-rouge">0</code> - Virtual line before first line of file<br /> <code class="language-plaintext highlighter-rouge">1</code> - First line of file<br /> <code class="language-plaintext highlighter-rouge">.</code> - Current line<br /> <code class="language-plaintext highlighter-rouge">$</code> - Last line of file <br /> <code class="language-plaintext highlighter-rouge">%</code> - All lines in the current file<br /> <code class="language-plaintext highlighter-rouge">'m</code> - Line containing mark m<br /> <code class="language-plaintext highlighter-rouge">'&lt;</code> - First line of visual selection<br /> <code class="language-plaintext highlighter-rouge">'&gt;</code> - Last line of visual selection</p><p>Offsets: Addresses can include offsets.<br /> <code class="language-plaintext highlighter-rouge">{address}+n</code></p><h1 id="modes-1">Modes</h1><ul><li>Normal</li><li>Insert</li><li>Replace (like Insert but overwrites existing text)</li><li>Visual (character-wise, block-wise, line-wise)</li><li>Select (like Visual but selected text will be replaced when typing)</li><li>Command line</li></ul><h1 id="tabs-and-spaces-options">Tabs and Spaces options:</h1><ul><li><code class="language-plaintext highlighter-rouge">tabstop</code>: Number of spaces that a <Tab> counts for</Tab></li><li><code class="language-plaintext highlighter-rouge">softtabstop</code>: Number of spaces that a <Tab> counts for while performing editing operations, like inserting a <Tab> or using <BS></BS></Tab></Tab></li><li><code class="language-plaintext highlighter-rouge">shiftwidth</code>: Number of spaces to use for each indent in Normal mode</li><li><code class="language-plaintext highlighter-rouge">expandtab</code>: Insert spaces instead of <Tab></Tab></li></ul><h1 id="uncategorized">Uncategorized</h1><ul><li>The Dot Formula: Use one keystroke to move and one keystroke to execute</li><li>Change in vim: Everything that happens from when we enter Insert mode until we return to Normal mode. Cursor keys (e.g. up, down) reset the change.</li><li>Action = operator + motion.</li><li>When an operator command is invoked in duplicate, it acts upon the current line.</li><li>Install exhuberant-ctag Debian package for using ctags on Linux.</li></ul><h1 id="plugins-to-consider">Plugins to consider:</h1><p><code class="language-plaintext highlighter-rouge">commentary.vim</code> - Adds command for (un)commenting lines of code in all languages supported by Vim.<br /> <code class="language-plaintext highlighter-rouge">unimpaired.vim</code> - Mappings for scrolling through the argument, quickfix, location, tag and buffer list.<br /> <code class="language-plaintext highlighter-rouge">vim-visual-star-search</code> - Make it easy to search for the selected text<br /> <code class="language-plaintext highlighter-rouge">vim-abolish</code> - Supercharged substitute command</p><h1 id="config-to-consider">Config to consider</h1><p><code class="language-plaintext highlighter-rouge">set history=2000</code> - length of vim command history, which is persisted across sessions<br /> <code class="language-plaintext highlighter-rouge">set wildmenu</code> - operate command-line completion in an enhanced mode<br /> <code class="language-plaintext highlighter-rouge">set wildmode=full</code> - complete the next full match<br /> <code class="language-plaintext highlighter-rouge">cnoremap &lt;expr&gt; %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'</code> - when we type %% on vim’s c: command-line prompt, it automatically expands to the path of the active buffer<br /> <code class="language-plaintext highlighter-rouge">set hlsearch</code> - highlight search matches<br /> <code class="language-plaintext highlighter-rouge">set incsearch</code> - Enable incremental searching<br /> <code class="language-plaintext highlighter-rouge">set smartcase</code> - Vim will attempt to predict out case sensitivity intentions<br /> <code class="language-plaintext highlighter-rouge">nnoremap &lt;silent&gt; &lt;C-l&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</code> - Mute search highlighting when redrawing screen<br /> <code class="language-plaintext highlighter-rouge">filtetype plugin on</code> - Enable the file-type detection plugin which enables to customize your config based on the type of the file in the current buffer</p><span class="meta"><time datetime="2024-08-12T00:00:00+01:00">August 12, 2024</time> &middot; <a href="/tag/vim">vim</a>, <a href="/tag/editor">editor</a>, <a href="/tag/cheatsheet">cheatsheet</a></span> <!--<span class="meta"><time datetime="2024-08-12T00:00:00+01:00">August 12, 2024</time> &middot; <a class="post" href="/tag/vim">vim</a>, <a class="post" href="/tag/editor">editor</a>, <a class="post" href="/tag/cheatsheet">cheatsheet</a></span> --></section></main></body></html>
